Finding kth largest element is a very common problem and the following are a very general ways of solving it

1. Sort -- O(nlogn)
The most intuitive way is to sort the array first and then return the kth largest number. The complexity of sorting is O(nlogn) 

2. Recursively Finding Maximum -- O(kn)
Step 1: Finding maximum in array O(n)
Step 2: new array = array.delete(maximum) 
Go back to step 1 until loop kth times

3. Quick Select -- O(n)
Recursively choose pivot (Step 1) and partition according to the pivot (Step 2). This approach follow divide and conquare algorithm, which is an algorithm design paradigm that recursively breaking down a problem into sub-problems. The solutions to the sub-problems are then combined to give a solution to the original problem
Reference: https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm

4. Max Heap -- O(n + klogn)
Make a max-heap by calling heapify. And then delete max k times

5. Min Heap -- O(nlogk)
Scan the array and maintain the k largest numbers seen so far in a min-heap

Approach 4 and Approach 5 uses Heap to solve this problem. 
Heap is a binary tree with the following two properties:
1. Structural Property: All levels of heap are completely filled and left-justified
2. Heap-order Property: For any node i, key (priority) of parent of i is larger than or equal to key of i (NOTE: This is defined for Max-Heap. Min-Heap is the same with opposite order property)

There are few operations for Heap
1. Bubble-Down / Bubble-Up: Traverse through entire binary tree and adjust the order of the tree -- O(logn), height of the tree
2. heapInsert: insert a new item into heap -- O(logn)
3. heapDelete: delete a item from heap -- O(logn)
4. heapify: Given n items and build a heap -- O(nlogn)
   Version 1: initialize H as empty heap
		for i to size(A) - 1
			heapInsert(A[i])
   Version 2: initialize H as empty heap
		for i = (len-1)/2 to 0
			bubble-down(A, i)
   version 2 runtime results in O(n)
